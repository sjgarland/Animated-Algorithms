# Notes about contents of my textbook

Some contents of the textbook, indicated below by daggers &dagger;, may supply material for the website.

Chapter 1 is a general introduction that talks about what it means to program well&dagger;:

+ selecting appropriate data structures to represent information, and
+ selecting understandable, verifiable, and flexible algorithms for processing information (in preference to ones that simply minimize length of code or execution time),
+ analyzing algorithms and data structures for speed, space, and clarity, and then making reasonable trade-offs among these factors, and
_what_ programs do (as opposed to _how_ they do it).

Chapters 2&ndash;3 cover the elementary details of programming (see Chapter 3.2 about sequence, choice and repetition). They show that even simple problems have many solutions, that some solutions are easier to communicate than others, and that it pays to analyze the merits of alternative solutions before choosing a particular solution. They also introduce important concepts such as programming style (Chapter 3.6&dagger;), program correctness (Chapter 3.7&dagger;), and the analysis of algorithms (Chapter 3.8&dagger;).

Chapter 4 covers functions and procedures. Chapter 4.6 introduces recursion&dagger;, both to stress its importance and to avoid the impression that it is so advanced a topic that it can be approached only after long study. Chapters 3&ndash;4 stress the importance of documenting the action of loops using invariant assertions and of documenting the action of procedures using preconditions and postconditions. Such assertions appear in sample programs throughout the book.&dagger;

Chapters 5&ndash;6 cover data structures. Chapter 5 introduces nonnumeric applications. Chapter 6 introduces composite data structures (array, record, and file) most commonly provided by programming languages.

Chapter 7 uses abstract actions on abstract data for multiple-precision arithmetic, variable-length strings, text editing, and scanning.

Chapter 8&dagger; covers the design and analysis of algorithms for searching and sorting.

Chapter 9 contains a case study in the design and development of a database system.

Chapter 10&dagger; illustrates the special nature of numeric computations by developing and analyzing several algorithms to approximate zeroes of functions. It also applies numeric techniques to simulate deterministic and nondeterministic systems. Typical applications include simulating the motion of a space vehicle, the outcome of a game of chance, or lines of customers waiting for service. Some of the material in this chapter is appropriate only for students with a more advanced knowledge of mathematics.

 Chapter 11&dagger; introduces linked data structures. It and Chapter 12 treat data structures as abstract data types; they emphasize the operations available to manipulate data rather than the physical representation of the data. Chapter 11 applies stacks and queues to problems arising earlier in the book, namely to translating recursive algorithms into iterative algorithms and to simulating waiting lines.

Chapter 12&dagger; covers binary trees and their application to searching and sorting. This chapter reveals the true power of recursion by using it to implement much clearer algorithms than are possible with iteration alone. The chapter concludes with a brief introduction to sets as a data type.

Chapter 13&dagger; applies the algorithms and data structures developed in Chapters 11&ndash;12 to several interesting problems. First it improves the treatment of multiple precision arithmetic carried out with more primitive data structures in Chapter 7. Then it shows how to parse arithmetic expressions using recursion. Finally, it uses trees to solve some simple problems in artificial intelligence.

The entire book contains numerous sample programs, both the make its approach to algorithms and data structures more concrete and also to provide models of good programs.
        </p>